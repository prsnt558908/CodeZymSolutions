public class FindVulnerabilityFactor {

    public FindVulnerabilityFactor() {
    }

    public int findVulnerabilityFactor(int[] key, int maxChange) {
        int n = (key == null) ? 0 : key.length;
        if (n == 0) return 0;

        // Build GCD sparse table for O(1) range-gcd queries.
        GcdSparseTable table = new GcdSparseTable(key);

        int lo = 0, hi = n; // answer in [0..n]
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2; // try vulnerability factor <= mid
            if (canMakeAtMost(table, n, mid, maxChange)) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        return lo;
    }

    /**
     * Check if we can ensure: every subarray with gcd > 1 has length <= L
     * by changing at most maxChange elements to 1.
     *
     * Key equivalence used:
     * vulnerabilityFactor <= L  <=>  every window of length (L+1) has gcd == 1.
     *
     * Then it becomes an interval stabbing problem:
     * "bad" windows (gcd > 1) of fixed length must each contain at least one changed index.
     * Greedy by right endpoints is optimal.
     */
    private boolean canMakeAtMost(GcdSparseTable table, int n, int L, int maxChange) {
        if (L >= n) return true; // no windows of length L+1 exist

        int w = L + 1;
        int changes = 0;
        int lastChangedIndex = -1; // last picked "stabbing point"

        // Scan windows by increasing right endpoint (since end = start + w - 1).
        for (int start = 0; start + w <= n; start++) {
            int end = start + w - 1;

            // If we already changed an index inside this window, it's automatically "fixed".
            if (lastChangedIndex >= start) continue;

            int g = table.query(start, end);
            if (g > 1) {
                // Need to hit this bad window; greedy choice is its right endpoint.
                changes++;
                lastChangedIndex = end;
                if (changes > maxChange) return false;
            }
        }
        return true;
    }

    // ----------------- Helpers -----------------

    private static class GcdSparseTable {
        private final int n;
        private final int[][] st;
        private final int[] lg;

        GcdSparseTable(int[] a) {
            this.n = a.length;

            // log table
            this.lg = new int[n + 1];
            lg[0] = -1; // unused
            if (n >= 1) lg[1] = 0;
            for (int i = 2; i <= n; i++) lg[i] = lg[i / 2] + 1;

            int LOG = 32 - Integer.numberOfLeadingZeros(n);
            this.st = new int[LOG][n];

            // level 0
            System.arraycopy(a, 0, st[0], 0, n);

            // build
            for (int j = 1; j < LOG; j++) {
                int len = 1 << j;
                int half = len >> 1;
                for (int i = 0; i + len <= n; i++) {
                    st[j][i] = gcd(st[j - 1][i], st[j - 1][i + half]);
                }
            }
        }

        int query(int l, int r) {
            int len = r - l + 1;
            int p = lg[len];
            int left = st[p][l];
            int right = st[p][r - (1 << p) + 1];
            return gcd(left, right);
        }
    }

    private static int gcd(int a, int b) {
        if (a == 0) return Math.abs(b);
        if (b == 0) return Math.abs(a);
        a = Math.abs(a);
        b = Math.abs(b);
        while (b != 0) {
            int t = a % b;
            a = b;
            b = t;
        }
        return a;
    }
}
