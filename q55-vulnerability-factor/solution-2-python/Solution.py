from math import gcd


class FindVulnerabilityFactor:
    def __init__(self):
        pass

    def findVulnerabilityFactor(self, key, maxChange):
        """
        Returns the minimum possible vulnerability factor after at most maxChange edits.

        Vulnerability factor = maximum length of any subarray whose GCD > 1.

        Key idea:
        For a target answer L, we must ensure that every window of length (L+1) has GCD == 1.
        Any window with GCD > 1 can be "fixed" by changing at least one element inside it to 1
        (since gcd(..., 1, ...) == 1).
        So we need to hit all bad windows with as few changed indices as possible.
        This is a classic interval stabbing problem, solvable greedily by choosing right endpoints.
        """
        n = len(key)
        if n == 0:
            return 0

        # Build GCD sparse table for O(1) range gcd queries.
        st, lg = self._build_gcd_sparse_table(key)

        def range_gcd(l, r):
            # gcd over key[l..r]
            length = r - l + 1
            p = lg[length]
            return gcd(st[p][l], st[p][r - (1 << p) + 1])

        def can_make_at_most(L):
            # Can we ensure all subarrays with GCD>1 have length <= L using <= maxChange edits?
            if L >= n:
                return True
            w = L + 1  # window size that must have gcd==1 everywhere

            changes = 0
            last_picked = -1  # last changed index (stabbing point)

            # scan windows by increasing end (equivalently increasing start)
            for start in range(0, n - w + 1):
                end = start + w - 1

                # already stabbed this window
                if last_picked >= start:
                    continue

                if range_gcd(start, end) > 1:
                    # need to stab: greedy pick the right end
                    changes += 1
                    last_picked = end
                    if changes > maxChange:
                        return False
            return True

        # Binary search answer in [0..n]
        lo, hi = 0, n
        while lo < hi:
            mid = (lo + hi) // 2
            if can_make_at_most(mid):
                hi = mid
            else:
                lo = mid + 1
        return lo

    def _build_gcd_sparse_table(self, a):
        n = len(a)
        # log table
        lg = [0] * (n + 1)
        for i in range(2, n + 1):
            lg[i] = lg[i // 2] + 1

        LOG = lg[n] + 1
        st = [[0] * n for _ in range(LOG)]
        st[0] = [abs(x) for x in a]  # gcd should use absolute values

        j = 1
        while (1 << j) <= n:
            half = 1 << (j - 1)
            limit = n - (1 << j) + 1
            row = st[j]
            prev = st[j - 1]
            for i in range(limit):
                row[i] = gcd(prev[i], prev[i + half])
            j += 1

        return st, lg
